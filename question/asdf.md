# 복습
- 문 : 컴퓨터에 내리는 명령 (표현식인 문, 표현식이 아닌 문)
  - 변수에 담을 수 있다면 표현식, 변수에 담을 수 없다면 표현식이 아닌 문
- 비순수 함수(외부 변수를 마음대로 바꿀 수 있는 함수)
- 함수형 프로그램 = 전역 변수를 줄이고, 반복문(for문)의 사용울 줄인다.
- 프로토타입은 부모 객체나 상위 객체라고 부르지 않는다. ('상위 객체의 역할을 하는 객체'가 맞다.)
- 프로토타입 객체는 이름이 없지만 함수가 만들어질 때 prototype 프로퍼티를 같이 생성하고 이 프로퍼티는 prototype 객체를 가리키게 된다. 프로토타입 객체는 Constructor 프로퍼티만을 가지고 시작한다.

# 전역 객체
- 브라우저는 window, node.js에서는 global
  - global = self
- window에는 빌트인 프로퍼티와 메서드, 전역 변수, 전역 함수 등이 들어가있다.
- 빌트인 함수를 찾아보기 위해서는 에디터에서 ''.을 쳐보면 api리스트가 뜬다.
- eval을 사용하면 최적화가 깨지고 보안에 문제가 생긴다. 사용자들이 할당할 데이터는 untrusted data이며 이 데이터로 이상한 코드를 태워보낼 경우, eval에 의해서 즉시 실행되며 문제가 생길 수 있어 대부분의 브라우저에서 막아놓았다.
- isNaN 많이 쓰임
- parseFloat: 소수점이 있는 실수로 해석해라. (문자열을 숫자로)
- parseInt: 소수점이 없는 정수로 해석 (문자역을 숫자로)
- URI에는 get 방식, post 방식
- #Intro는 페이지 내에서 이동할 때에 사용함(향후 내용 더 추가)
# this
- this는 기본적으로 window 전역 객체를 가지고 시작하며 함수가 평가 될 때마다 그에 맞춰 바뀐다.
- 중첩함수, 콜백 함수는 대체로 외부 함수를 도와주는 헬프 함수 역할을 위해 만들어짐.
- function 객체는 function 생성자 함수가 만들었다고 친다.
- 일반 객체 체인에는 function.prototype이 존재하지 않으므로 function.prototype이 가지고 있는 메서드를 가져다 쓸 수 없다.
- function.prototype.apply/call/bind 메소드는 함께 기억하는 것이 좋다.
  - apply : 호출 후 갈아끼운다.
  - call : 호출한다.
  - bind :
- Math.max(1, 2, 3) 정적메서드 가변인자변수, 정적 메서드인 Math 같은 경우는 this를 쓰지 않는다(this 값이 없음).
  - (ES5) Math.max.apply(null,  arr);
  - (ES6) Math.max.apply(...arr);
- 만약 가변인자변수를 받는 메서드라면 인수의 갯수가 달라질 수 있어서 문제가 될 수 있다.
- callback.bind(this)(); = callback.apply(this); = callback.call(this);
  - apply와 call은 호출을 하기 위한 메소드이므로 호출을 따로 필요로 하지 않는다.
  - 간접 호출